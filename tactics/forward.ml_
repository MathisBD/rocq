(************************************************************************)
(*         *      The Rocq Prover / The Rocq Development Team           *)
(*  v      *         Copyright INRIA, CNRS and contributors             *)
(* <O___,, * (see version control and CREDITS file for authors & dates) *)
(*   \VV/  **************************************************************)
(*    //   *    This file is distributed under the terms of the         *)
(*         *     GNU Lesser General Public License Version 2.1          *)
(*         *     (see LICENSE file for the text of the license)         *)
(************************************************************************)

open Pp
open CErrors
open Util
open Names
open Nameops
open Constr
open Context
open Termops
open Environ
open EConstr
open Vars
open Namegen
open Declarations
open Inductiveops
open Reductionops
open Evd
open Tacred
open Logic
open Clenv
open Tacticals
open Hipattern
open Rocqlib
open Evarutil
open Indrec
open Pretype_errors
open Unification
open Locus
open Locusops
open Tactypes
open Proofview.Notations
open Context.Named.Declaration
open TacticExceptions
open ContextTactics
open ConvTactics
open HypNaming

module RelDecl = Context.Rel.Declaration
module NamedDecl = Context.Named.Declaration

let typ_of env sigma c =
  let open Retyping in
  try get_type_of ~lax:true env sigma c
  with RetypeError e ->
    CErrors.user_err (print_retype_error e)

let clear_hyps2 env sigma ids sign t cl =
  try
    Evarutil.clear_hyps2_in_evi env sigma sign t cl ids
  with Evarutil.ClearDependencyError (id,err,inglobal) ->
    Loc.raise (ReplacingDependency (env,sigma,id,err,inglobal))

let internal_cut ?(check=true) replace id t =
  Proofview.Goal.enter begin fun gl ->
    let env = Proofview.Goal.env gl in
    let sigma = Tacmach.project gl in
    let concl = Proofview.Goal.concl gl in
    let sign = named_context_val env in
    let r = Retyping.relevance_of_type env sigma t in
    let env',t,concl,sigma =
      if replace then
        let nexthyp = get_next_hyp_position env sigma id (named_context_of_val sign) in
        let sigma,sign',t,concl = clear_hyps2 env sigma (Id.Set.singleton id) sign t concl in
        let sign' = insert_decl_in_named_context env sigma (LocalAssum (make_annot id r,t)) nexthyp sign' in
        Environ.reset_with_named_context sign' env,t,concl,sigma
      else
        (if check && mem_named_context_val id sign then
           Loc.raise (IntroAlreadyDeclared id);
         push_named (LocalAssum (make_annot id r,t)) env,t,concl,sigma) in
    let nf_t = nf_betaiota env sigma t in
    Proofview.tclTHEN
      (Proofview.Unsafe.tclEVARS sigma)
      (Refine.refine_with_principal ~typecheck:false begin fun sigma ->
        let (sigma, ev) = Evarutil.new_evar env sigma nf_t in
        let (sigma, ev') = Evarutil.new_evar env' sigma concl in
        let term = mkLetIn (make_annot (Name id) r, ev, t, EConstr.Vars.subst_var sigma id ev') in
        (sigma, term, Some (fst @@ destEvar sigma ev'))
      end)
  end

let assert_before_then_gen b naming t tac =
  let open Context.Rel.Declaration in
  Proofview.Goal.enter begin fun gl ->
    let id = find_name ~replace:b (LocalAssum (make_annot Anonymous Sorts.Relevant, t)) naming gl in
    Tacticals.tclTHENLAST
      (internal_cut b id t)
      (tac id)
  end

let assert_before_gen b naming t =
  assert_before_then_gen b naming t (fun _ -> Proofview.tclUNIT ())

let assert_before ?(replace = false) na =
  assert_before_gen replace (naming_of_name na)

let replace_error_option err tac =
  match err with
    | None -> tac
    | Some (e, info) ->
      Proofview.tclORELSE tac (fun _ -> Proofview.tclZERO ~info e)

let assert_after_then_gen b naming t tac =
  let open Context.Rel.Declaration in
  Proofview.Goal.enter begin fun gl ->
    let id = find_name ~replace:b (LocalAssum (make_annot Anonymous Sorts.Relevant,t)) naming gl in
    Tacticals.tclTHENFIRST
      (internal_cut b id t <*> Proofview.cycle 1)
      (tac id)
  end

let assert_after_gen b naming t =
  assert_after_then_gen b naming t (fun _ -> (Proofview.tclUNIT ()))

let assert_after ?(replace = false) na =
  assert_after_gen replace (naming_of_name na)


let prepare_intros_opt with_evars dft destopt ipat =
  let naming, loc, ipat = match ipat with
  | None ->
    let pat = IntroNaming dft in make_naming_pattern Id.Set.empty [] pat, None, pat
  | Some {CAst.loc;v=(IntroNaming pat as ipat)} ->
    (* "apply ... in H as id" needs to use id and H is kept iff id<>H *)
    prepare_naming ?loc pat, loc, ipat
  | Some {CAst.loc;v=(IntroAction pat as ipat)} ->
    (* "apply ... in H as pat" reuses H so that old H is always cleared *)
    (match dft with IntroIdentifier _ -> prepare_naming ?loc dft | _ -> make_naming_action Id.Set.empty [] pat),
    loc, ipat
  | Some {CAst.loc;v=(IntroForthcoming _)} -> assert false in
  naming, prepare_action ?loc with_evars destopt ipat

let ipat_of_name = function
  | Anonymous -> None
  | Name id -> Some (CAst.make @@ IntroNaming (IntroIdentifier id))

let head_ident sigma c =
   let c = fst (decompose_app sigma (snd (decompose_lambda_decls sigma c))) in
   if isVar sigma c then Some (destVar sigma c) else None

(* apply in as *)

let general_apply_in ?(respect_opaque=false) with_delta
    with_destruct with_evars id lemmas ipat then_tac =
  let tac (naming,lemma) tac id =
    apply_in_delayed_once ~respect_opaque with_delta
      with_destruct with_evars naming id lemma tac in
  Proofview.Goal.enter begin fun gl ->
  let destopt =
    if with_evars then MoveLast (* evars would depend on the whole context *)
    else (
      let env, sigma = Proofview.Goal.(env gl, sigma gl) in
      get_previous_hyp_position env sigma id (Proofview.Goal.hyps gl)
    ) in
  let naming,ipat_tac =
    prepare_intros_opt with_evars (IntroIdentifier id) destopt ipat in
  let lemmas_target, last_lemma_target =
    let last,first = List.sep_last lemmas in
    List.map (fun lem -> (NamingMustBe (CAst.make id),lem)) first, (naming,last)
  in
  (* We chain apply_in_once, ending with an intro pattern *)
  List.fold_right tac lemmas_target
    (tac last_lemma_target (fun id -> Tacticals.tclTHEN (ipat_tac id) then_tac)) id
  end

(*
  if sidecond_first then
    (* Skip the side conditions of the applied lemma *)
    Tacticals.tclTHENLAST (tclMAPLAST tac lemmas_target) (ipat_tac id)
  else
    Tacticals.tclTHENFIRST (tclMAPFIRST tac lemmas_target) (ipat_tac id)
*)

let apply_in simple with_evars id lemmas ipat =
  let lemmas = List.map (fun (k,{CAst.loc;v=l}) -> k, CAst.make ?loc (Proofview.tclUNIT l)) lemmas in
  general_apply_in simple simple with_evars id lemmas ipat Tacticals.tclIDTAC

let apply_delayed_in simple with_evars id lemmas ipat then_tac =
  general_apply_in ~respect_opaque:true simple simple with_evars id lemmas ipat then_tac


(* Tactics "pose proof" (usetac=None) and "assert"/"enough" (otherwise) *)
let forward b usetac ipat c =
  match usetac with
  | None ->
      Proofview.Goal.enter begin fun gl ->
      let t = Tacmach.pf_get_type_of gl c in
      let sigma = Tacmach.project gl in
      let hd = head_ident sigma c in
      let assert_as =
        let naming,tac = prepare_intros_opt false IntroAnonymous MoveLast ipat in
        let repl = do_replace hd naming in
        if repl then assert_before_gen true naming t
        else assert_before_then_gen false naming t tac
      in
      Tacticals.tclTHENFIRST assert_as (exact_no_check c)
      end
  | Some tac ->
      let tac = match tac with
        | None -> Tacticals.tclIDTAC
        | Some tac -> Tacticals.tclCOMPLETE tac in
      let naming, assert_tac = prepare_intros_opt false IntroAnonymous MoveLast ipat in
      if b then
        Tacticals.tclTHENFIRST (assert_before_then_gen false naming c assert_tac) tac
      else
        Tacticals.tclTHENS3PARTS
          (assert_after_then_gen false naming c assert_tac) [||] tac [|Tacticals.tclIDTAC|]

let pose_proof na c = forward true None (ipat_of_name na) c
let assert_by na t tac = forward true (Some (Some tac)) (ipat_of_name na) t
let enough_by na t tac = forward false (Some (Some tac)) (ipat_of_name na) t
